## 옵셔널, 함수

---

## INDEX

[1. 옵셔널](#옵셔널)

-   [1.1. 옵셔널 타입의 선언과 정의](#1.1.-옵셔널-타입의-선언과-정의)
-   [1.2. 옵셔널 값 처리](#1.2.-옵셔널-값-처리)
-   [1.3. 옵셔널 바인딩](#1.3.-옵셔널-비강제-해제)


[2. 함수](#2.-함수)

-   [2.1. 사용자 정의 함수](#2.1.-사용자-정의-함수)
-   [2.2. 함수 호출](#2.2.-함수-호출)
-   [2.3. 가변 인자](#2.3.-가변-인자)
-   [2.4. 일급 객체로서의 함수](#2.4.-일급-객체로서의-함수)

<br>
<br>


## 1. 옵셔널
---

> 옵셔널(Optional)은 스위프트에서 도입된 새로운 개념으로서 <u>**언어 차원에서 프로그램의 안정성을 높이고자 사용하는 개념**</u>이다.
>
> 옵셔널은 성공적으로 값을 반환한다는 보장이 없는, 즉 값을 처리하는 과정에서 오류가 발생할 가능성이 있는 값을 **옵셔널 타입**이라는 객체로 감싼 후 반환한다.

이를 **옵셔널 래핑 (Optional Wrapping)** 이라고 한다.

여기서 중요한 점은 "**오류가 발생할 가능성**"이다.

즉, 오류가 발생할 가능성이 조금이라도 있는 값은 모두 옵셔널 타입으로 감싸 전달한다.

스위프트는 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력한다. 오류가 발생하면 프로그램의 실행 흐름이 중단되고 경우에 따라 앱이 죽어버릴 수 있으므로, 언어의 안정성을 위해서는 될 수 있으면 피해야 하는 상황일 수 밖에 없다.

타 언어에서 `Null`, `null` 로 표현되기도 하는 `nil` 은 **값이 없다** 라는 것을 표현하기 위한 특수 값이다.

**기존의 `objective-c` 에서는 빈 메모리 주소를 가리키는 값이었으나 스위프트에서는 단순히 `값이 없음`을 의미하게 되었다.**

또한, 스위프트는 일반적인 자료형은 `nil` 값을 가질 수 없도록 제약을 걸어두었다.

즉, 문자열이나 정수 등과 같은 일반 자료형은 `값이 없음` 이라는 이라는 값이 저장될 수 없도록 차단되어 있기 때문에 억지로 `nil`값을 대입하려 해도 대입이 불가능하다.

함수나 메소드를 통한 값 반환에도 마찬가지다. 반환 타입이 정해져 있기 때문에 그 타입에 맞게 값을 반환해야 하는데, 처리 과정이 실패했을 경우에는 `nil` 을 반환하게 된다.

옵셔널 타입이 실제로 가질 수 있는 값의 종류는 두 가지다.

> 1. 오류가 발생할 가능성이 있으나 실제 실행 결과에서 오류가 발생하지 않았을 때 반환되는 `nil`이 아닌 값, -> `Optional` 타입에 wrapping 되어 있는건 동일하다.
>
> 2. 실제 실행 결과에서 오류가 발생했을 때 반환되는 `nil` 값
>

만일 처리 결과가 성공이라면 특수한 처리 과정을 통해 옵셔널 타입을 해제 (Unwrapping) 하고 실제 값을 추출하여 사용해야 한다.

만일 처리 결과가 실패라면 옵셔널 타입의 값은 `nil` 값을 반환하므로 옵셔널 타입을 해제해서는 안된다.

<br>
<br>

### 1.1. 옵셔널 타입의 선언과 정의
---

일반 자료형을 옵셔널 타입으로 정의하는 방법은 매우 단순하다.

> 우리가 사용하는 자료형 뒤에 `?` 만 붙이면 된다.

`String?` 은 옵셔널 String 타입을 의미하고, `Int?`는 옵셔널 Int 타입을 의미한다.

옵셔널 타입의 변수에 값을 할당할 때에는 옵셔널 타입임을 인지할 필요가 거의 없다.

일반 변수처럼 생각하고 값을 대입해도 된다.

<br>
<br>

### 1.2. 옵셔널 값 처리
---

> 옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다.

옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다.

따라서 옵셔널 타입과 일반 타입은 서로 연산이 불가능하며 옵셔널 타입끼리의 연산이나 결합 또한 지원하지 않는다.

이러한 옵셔널 값을 사용하는 방법에 대해 살펴본다.

> 우리가 전달받은 것은 `Optional` 이라는 객체이다.
>
> 그 객체 내부에 우리가 원하는 값이 들어있다. 
>
> 이 값을 우리가 원하는 대로 사용하기 위해서는 실제 값을 둘러싸고 있는 **옵셔널 객체를 해제**해야한다.

옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 그 값이 우리가 직접 사용할 수 있는 값이다.

> 이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 **옵셔널 해제 (Optional Unwrapping)** 이라고 한다.

> 옵셔널 해제 방식은 **명시적 해제**와 **묵시적 해제**로 나뉜다.

명시적 해제는 강제 해제와 비강제 해제로 나뉘고 묵시적 해제는 자동 해제와 `!` 연산자를 사용한 자동 해제로 나눌 수 있다.

강제 해제는 옵셔널 값의 `nil` 여부와는 상관없이 그냥 옵셔널을 무조건 해제하는 방식으로, 스위프트 공식 문서에서는 `Forced Unwrapping` 이라는 용어를 사용한다.

>  강제 해제 방법은 매우 간단하다. 옵셔널 변수 뒤에 `!` 연산자만 붙이면 옵셔널 객체가 해제되고 내부에 저장된 값을 추출할 수 있다.

아래 예시를 살펴본다.

```swift
var optInt:Int? = 3

print("Optional value : \(optInt)")
// Optional(3)

print("Forced Unwrapping value : \(optInt!)")
// 3
```

> 이처럼 옵셔널 타입으로부터 값을 강제 추출하기 위해서는 옵셔널 값 뒤에 `!` 연산자를 붙이면 된다.

이를 사용하면 옵셔널 타입끼리의 연산 또한 처리할 수 있다.

> 옵셔널 변수의 값이 `nil` 일 때, 강제 해제를 진행하면 오류가 발생한다.

그래서 옵셔널 변수나 상수등을 안전하게 사용하려면 조건이 따른다.

강제 해제 연산자를 사용할 때에는 옵셔널 값이 `nil`인지 우선 점검해야 한다.

> 이후 옵셔널 값이 `nil`이 아닐 때에만 강제 해제 연산자를 통해 값을 추출해야 한다.

```swift

var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었음, 변환값은 \(intFromStr)입니다.")
} else {
    print("값 변환에 실패하였음.")
}

```

> 옵셔널은 값이 없는 `nil` 이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 `nil`인지를 `if`, `guard`등을 통해 점검한 이후 사용해야한다.

<br>
<br>

### 1.3. 옵셔널 바인딩 (옵셔널 비강제 해제)

앞에서 우리는 `nil` 여부를 체크하여 안전하게 옵셔널 타입을 해제할 수 있었다.

위에서 진행한 내용을 비강제적인 해제를 이용해 작성이 가능하다.

> 비강제 해재 구문은 `if` 문과 같은 구문 내에서 조건식 대신에 옵셔널 타입의 
> 
> 값을 변수 또는 상수에 할당하는 구문을 사용하는 방식으로, 옵셔널 바인딩 
> 
> (Optional Binding) 이라고 한다.

`if`문의 조건절을 이용해 옵셔널 바인딩을 진행하는 예제를 살펴본다.

```swift

var str = "Swift"

if let intFromStr = Int(Str) {
    print("값이 변환되었음, 변환값은 \(intFromStr)입니다.")
}   else {
    print("값 변환에 실패하였음.")
}
```

앞서 살펴봤던 강제 해제와 비슷하지만, `intFromStr`이 `if` 문의 조건절에서 **상수**로 선언되었다는 차이가 존재한다.

> 옵셔널 타입의 값이 만일 존재할 경우, 상수 또는 변수에 할당하는 과정을 거치며 
> 
> 자연스럽게 옵셔널 타입이 해제되지만, 옵셔널 타입의 값이 `nil`일 경우에는 값의 
> 
> 할당이 실패되어 실패 분기로 진행되도록 한다.

```swift
func intStr(str:String) {

    guard let intFromStr = Int(Str) else {
        print("값 변환에 실패하였음.")
        return
    }

    print("값이 변환되었음. 변환값은 \(intFromStr)입니다.")
}

```

위 구문은 `guard` 구문을 이용해 옵셔널 바인딩을 구현한 예제이다.

`guard` 구문 또한 작동 방식은 동일하다. `guard` 구문은 조건에 맞지 않으면 무조건 함수 실행을 종료시키기 때문에, 실행 흐름상 옵셔널 값이 해제되지 않으면 더이상 진행이 불가한 경우에 이용된다.

만일, 형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 `nil` 값이 대입될 가능성이 없는 변수인 경우가 있다.

> `guard` 구문은 함수 또는 메소드에서만 사용이 가능하다.
> 
> `if` 구문을 이용한 옵셔널 바인딩은 조건에 따라서 다른 피드백을 나타낼 때 이용한다.
> 
> `guard` 구문을 이용한 옵셔널 바인딩은 옵셔널 해제가 정상적으로 이루어지지 않았을 때, 프로그램의 흐름상 문제가 될 경우 사용한다. 

```swift
var value01: Int? = 10
```

위처럼 Optional Int 타입이지만 우리가 정확히 10을 대입해줘서 값이 있음을 확신할 때에는 묵시적 옵셔널 해제를 이용한다.

묵시적 해제는 컴파일러에 의한 옵셔널 자동 해제와 '!' 연산자를 통한 자동 해제 방법이 있다.

```swift
let optInt = Int("123")

// 옵셔널 강제 해제 후 비교
if ((optInt!) == 123) {
    print("optInt == 123")
} else {
    print("optInt != 123")
}

// 컴파일러에 의한 옵셔널 자동 해제
if(optInt == 123) {
    print("optInt == 123")
} else {
    print("optInt != 123")
}
```

두번쨰 `if`문에서는 옵셔널을 해제하지 않아 `optInt` 값이 `Optional(123)`일 것으로 예상하고 조건이 맞지않아 `else`문이 실행될 것으로 예상되지만, 컴파일러에서 자동으로 옵셔널을 해제해준다.

이를 묵시적 해제라고 한다.



```swift
var value01 : Int! = 10
value01 + 5 // 15
```

위 방법은 형식상 옵셔널로 정의해야 하지만 변수의 값이 `nil`이 될 가능성이 없을 경우 사용하는 방법이다.

이처럼 `nil`이 될 가능성이 없는 옵셔널 타입 선언시 `!` 연산자를 사용하여 일반 변수처럼 사용이 가능하다.




<br>
<br>


## 2. 함수
---

함수는 일반 함수와 사용자 정의 함수로 나눌 수 있다.

일반 함수는 프로그래밍 언어 또는 프레임워크에서 제공하는 함수로 기본적 연산 또는 처리 등을 수행하기 위한 목적으로 사용된다.

대표적으로 표준출력에 사용되는 `print()`가 있다.

그 외의 필요에 따라 사용자가 직접 만들어 사용하는 함수를 **사용자 정의 함수** 라고한다.

함수를 만들어서 사용하는 이유는 다음과 같은 이점 때문이다.

#### 함수를 사용하는 이유
> - 동일한 코드가 여러 곳에서 사용될 떄 이를 함수화 하면 재작성할 필요 없이 호출만으로 처리할 수 있다.
> 
> - 전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드의 흐름과 로직을 이해하기 쉽다.
> 
> - 비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수에 용이하다.


### 2.1. 사용자 정의 함수

사용자 정의 함수를 만드는 형식은 아래와 같다.

```swift

func 함수명 (매개변수1: 타입, 매개변수2: 타입...) -> 반환 타입 {
    
    함수 몸체

    return 반환값
}
```

타 언어에서 함수를 만드는 방법과 유사하다.

> 스위프트에서는 명시적으로 `func` 라는 키워드를 통해 함수를 선언한다.

만일 함수의 인자값이 필요 없는 경우라면 매개변수는 당연히 생략될 수 있다.

> 또한, 함수의 반환 타입을 표시할 때에는 `->` 기호와 함께 사용한다.

이 기호 다음에 작성된 자료형은 이 함수가 반환하는 값의 타입을 의미한다.

> 함수의 반환 타입 자료형에는 제약이 없다, 일반적인 String, Int, DOuble, Bool 등과 같은 기본 자료형 외에도 AnyObject, UITableCell 등 클래스의 객체도 사용할 수 있다.

반환값 또한 없을 경우에는 `->` 기호를 생략하면 된다.

### 2.2. 함수 호출


이제 함수를 호출하는 방법에 대해 살펴보자.

```swift

func incrementBy(amount: Int, numberOfTimes: Int) {
    var cnt = 0
    cnt = amount * numberOfTimes
}
```

위와 같은 함수가 존재한다고 해보자.

해당 함수는 두개의 매개변수를 받기 때문에 이 함수를 호출할 때는 다음과 같이 인자값 앞에 해당 매개변수의 레이블을 기재해야한다.

```swift
incrementBy(amount: 5, numberOfTimes: 20)
```

함수를 호출할 때에도 반드시 레이블을 포함하도록 강제하는 것은 스위프트 측이 강조하는 장점 즉, 레이블 미표기로 인한 혼란이나 불편함을 방지하기 위함이라고 한다.

( 솔직히 잘 모르겠다; 타 언어에서 함수호출시 위에서 언급한 불편함을 겪어본 경험이 없다. )

<br>
<br>

### 2.3. 가변 인자

일반적으로 함수는 미리 정의된 형식과 개수에 맞는 인자값만 처리하는 것이 일반적이지만, 때에 따라서는 가변적 개수의 인자값을 입력받아야 할 때도 있다.

> 스위프트는 이러한 가변 인자 입력 방식을 지원하는데, 아래와 같이 함수를 정의할 때 매개변수명 다음에 `...` 연산자를 추가한다.

```swift
func 함수명(매개변수명 : 매개변수 타입 ...)

```

이렇게 정의된 매개변수는 가변 인자로 인식되어 인자의 개수를 제한하지 않고 인자값을 입력받으며, 입력된 인자값을 배열로 저장한다.

```swift
func avg(score: Int...) -> Double {

    var total = 0
    for r in score {        // score 배열 원소 순회
        total += r
    }

    return (Double(total) / Double(score.count))    // 총합값을 배열 길이로 나눔
}
```

이처럼 가변 인자값은 입력 개수를 특정할 수 없는 형태의 매개변수에서 사용된다.

빈번히 사용되지는 않지만, 가변 인자가 아니면 같은 결과를 얻기 위해 꽤 복잡한 과정을 거쳐야 할 경우가 있다고 하니 꼭 기억해두자.
<br>
<br>

### 2.4. 일급 객체로서의 함수

스위프트는 객체지향 언어이자 동시에 함수형 언어이다.

함수형 언어들을 공부하다보면 `일급 시민, 일급 객체` 라는 용어를 접하게 된다.

이는 프로그램 언어 안에서 특정 조류의 객체가 일급의 지위를 가지는가에 대한 의미이다.

**일급 함수의 특성**

객체가 다음 조건을 만족하는 경우 이 객체를 일급 객체로 간주한다.

1. 객체가 런타임에도 생성이 가능해야 한다.
2. 인자값으로 객체를 전달할 수 있어야 한다.
3. 반환값으로 객체를 사용할 수 있어야 한다.
4. 변수나 데이터 구조 안에 저장할 수 있어야 한다.
5. 할당에 사용된 이름과 관계없이 고유한 구별이 가능해야 한다.

함수가 위 조건을 만족하면 이를 일급 함수라고 하고 그 언어를 함수형 언어로 분류한다.

즉, 함수형 언어에서는 함수가 일급 객체로 대우받는다는 의미이다.

지금부터 일급 함수의 특성에 대해 단계적으로 하나씩 살펴보도록 한다.

1. 변수나 상수에 함수를 대입할 수 있음

```swift
func foo(base: Int) -> String {
    return "결과값: \(base + 1)"
}

let fn1 = foo(base: 5)
```

위 `foo` 라는 함수에 인자값을 넣어 실행하고 이를 fn1 상수에 할당하고 있다.

변수나 상수에 함수를 대입할 수 있다는 성질은 위 의미와는 다르다.

위 내용은 함수의 결과값을 변수나 상수에 대입하는 것이지, 함수 자체를 대입하는것이 아니다.

아래 예를 살펴보자.

```swift
let fn2 = foo       // fn2 상수에 foo 함수가 할당됨
fn2(5)              // 결과값: 6
```

상수 fn2에 `foo` 함수 자체를 대입하고 있다.

함수 자체가 대입되었으므로 이제 fn2는 foo와 이름만 다를 뿐 인자값, 같은 기능, 같은 반환값을 가지는 함수가 된다.

2.  함수의 반환 타입으로 함수를 사용할 수 있음

일급 함수의 특성 중 두 번쨰는 함수의 반환 타입으로 함수를 사용한다는 것이다.

일급 객체로 대우받는 함수는 실행 결과로 정수, 실수, 문자열 등 기본 자료형 또는 클래스, 구조체 등의 객체를 반환할 수 있을 뿐만 아니라 함수 자체를 반환할 수도 있다.

함수가 함수를 반환하다는 의미를 아래 예제를 통해 이해해보도록 한다.

```swift
func desc() -> String {
    return "this is desc()"
}

func pass() -> (void) -> String {
    return desc
}

let p = pass()
p()             // "this is desc()"
```

가장 위에 작성된 desc함수는 인자값 없이 문자열을 반환하는 함수 형식으로 정의되어 있다.

그 이후 작성된 함수는 pass 함수다. 이 함수의 내부 블럭을 살펴보면 다른 실행 구문 없이 `desc` 함수 자체를 반환한다.

즉, 함수가 함수를 반환하고 있으며 반환하는 함수의 반환값은 `String`이다.

이는 pass 함수가 desc 함수를 반환하므로 `(void) ->  String` 으로 반환값을 표기한다.

이를 응용한 예시를 살펴본다

```swift

func plus(a: Int, b: Int) -> Int {
    return a+b
}

func minus(: Int, b:Int) -> Int {
    return a-b
}

func times(a: Int, b:Int) -> Int {
    return a*b
}

func divide(a: Int, b:Int) -> Int {
    guard b != 0 else {     // divide by zero exception
        return 0
    }
    return a/b
}

func call(_ operand: String) -> (Int, Int) -> Int {
    
    switch operand {
        case "+":
            return plus
        
        case "-":
            return minus
        
        case "*":
            return times
        
        case "/":
            return divide

        default :
            return plus
    }
}


let c = calc('+')
c(3,4)          // plus 3+4 = 7 

```

`call` 함수를 보면 1차 인자값으로 operand를 전달받는다. 이후 2차 인자값으로 피연산자들의 값을 전달받아 연산을 진행한다.

3. 함수의 인자값으로 함수를 사용할 수 있음

일급 함수는 반환값으로 함수를 사용할 수 있을 뿐만 아니라 다른 함수의 인자값으로 함수를 전달할 수 있는 특성을 가지고 있다.

이를 이해하기 위해서는 **콜백 함수** 개념을 이해해야 한다.

콜백 함수는 특정 구문의 실행이 끝나면 시스템이 호출하도록 처리된 함수를 의미한다.

아래 예시를 살펴보자

```swift

func incr(param: Int) -> Int {
    return param + 1
}

func broker(base: Int, function fn: (Int) -> Int) -> Int {
    return fn(base)
}

broker(base:3, function:incr)

```
위 예시는 함수의 인자로 함수를 사용하는 예시이다.

broker 함수의 인자로 함수를 받고 있으며 인자 함수는 Int값을 매개변수로 갖고 반환값 또한 Int값을 갖는다.


이번에는 콜백 함수를 사용하는 예시를 살펴보도록 한다.

```swift

func successThrough() {
    print("연산 처리 성공")
}

func failThrough() {
    print("연산 처리 실패")
}

func divide(base: Int, success sCallBack: (Void)-> Void, fail fCallBack: (Void) -> Void) -> Int {

    guard base != 0 else {
        fCallBack()
        return 0
    }

    defer {
        sCallBack()
    }
    
    return 100
}

divide(base: 30, success: successThrough, fail: failThrough)
```

위 예제는 함수 인자를 사용하여 콜백을 처리하고 있다.

함수의 두번쨰 인자는 내부 연산 과정이 성공적으로 완료되었을 때 실행할 함수이며, 세번째 인자는 내부 연산 과정이 실패했을 때 실행할 함수이다.








<br>
<br>


### 정리
---

- **옵셔널은 프로그램의 안정성을 위한 개념이다.**

- **nil은 기존의 `objective-c` 에서는 빈 메모리 주소를 가리키는 값이었으나 스위프트에서는 단순히 `값이 없음`을 의미하게 되었다.**

- **일반 자료형에는 `nil`값을 할당할 수 없다. 하지만 각각의 일반 자료형들을 기반으로 옵셔널 타입이 만들어진다. (ex: Optional Int, Optional String)**

-   **옵셔널 타입이 가질 수 있는 값은 `nil` || `옵셔널 타입에 쌓여진 nil이 아닌 값`**

-   **옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 **옵셔널 해제 (Optional Unwrapping)** 이라고 한다.**

-   **옵셔널 타입으로부터 값을 강제 추출하기 위해서는 옵셔널 값 뒤에 `!` 연산자를 붙이면 된다.**

-   **옵셔널은 값이 없는 `nil` 이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 `nil`인지를 `if`, `guard`등을 통해 점검한 이후 사용해야한다.**

-   **`if` 문과 같은 구문 내에서 조건식 대신에 옵셔널 타입의 값을 변수 또는 상수에 할당하는 구문을 사용하는 방식으로, 옵셔널 바인딩 (Optional Binding) 이라고 한다. ex ) if let intFromStr = Int(Str) { }**

-   **[함수를 사용하는 이유](#함수를-사용하는-이유)**

-   **함수를 호출할 떄에는 매개변수 레이블을 기재하여 호출해야 한다.**

-   **가변인자 받는법 :func avg(score: Int `...`) -> Double {}**