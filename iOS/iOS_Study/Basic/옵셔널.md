## 옵셔널, 함수

---

## INDEX

[1. 옵셔널](#옵셔널)

-   [1.1. 옵셔널 타입의 선언과 정의](#1.1.-옵셔널-타입의-선언과-정의)
-   [1.2. 옵셔널 값 처리](#1.2.-옵셔널-값-처리)
-   [1.3. 옵셔널 바인딩](#1.3.-옵셔널-바인딩)


[2. 함수](#2.-함수)

-   [2.1. 사용자 정의 함수](#2.1.-사용자-정의-함수)
-   [2.2. 함수 호출](#2.2.-함수-호출)
-   [2.3. 가변 인자](#2.3.-가변-인자)

<br>
<br>


## 1. 옵셔널
---

옵셔널(Optional)은 스위프트에서 도입된 새로운 개념으로서 언어 차원에서 프로그램의 안정성을 높이고자 사용하는 개념이다.

옵셔널은 성공적으로 값을 반환한다는 보장이 없는, 즉 값을 처리하는 과정에서 오류가 발생할 가능성이 있는 값을 **옵셔널 타입**이라는 객체로 감싼 후 반환한다.

이를 **옵셔널 래핑 (Optional Wrapping)** 이라고 한다.

여기서 중요한 점은 "오류가 발생할 가능성"이다.

즉, 오류가 발생할 가능성이 조금이라도 있는 값은 모두 옵셔널 타입으로 감싸 전달한다.

스위프트는 언어의 안정성을 위해 가급적 오류를 발생시키지 않으려고 노력한다. 오류가 발생하면 프로그램의 실행 흐름이 중단되고 경우에 따라 앱이 죽어버릴 수 있으므로, 언어의 안정성을 위해서는 될 수 있으면 피해야 하는 상황일 수 밖에 없다.

타 언어에서 `Null`, `null` 로 표현되기도 하는 `nil` 은 **값이 없다** 라는 것을 표현하기 위한 특수 값이다.

**기존의 `objective-c` 에서는 빈 메모리 주소를 가리키는 값이었으나 스위프트에서는 단순히 `값이 없음`을 의미하게 되었다.**

또한, 스위프트는 일반적인 자료형은 `nil` 값을 가질 수 없도록 제약을 걸어두었다.

즉, 문자열이나 정수 등과 같은 일반 자료형은 `값이 없음` 이라는 이라는 값이 저장될 수 없도록 차단되어 있기 때문에 억지로 `nil`값을 대입하려 해도 대입이 불가능하다.

함수나 메소드를 통한 값 반환에도 마찬가지다. 반환 타입이 정해져 있기 때문에 그 타입에 맞게 값을 반환해야 하는데, 처리 과정이 실패했을 경우에는 `nil` 을 반환하게 된다.

옵셔널 타입이 실제로 가질 수 있는 값의 종류는 두 가지다.

> 1. 오류가 발생할 가능성이 있으나 실제 실행 결과에서 오류가 발생하지 않았을 때 반환되는 `nil`이 아닌 값, -> `Optional` 타입에 wrapping 되어 있는건 동일하다.
>
> 2. 실제 실행 결과에서 오류가 발생했을 때 반환되는 `nil` 값
>

만일 처리 결과가 성공이라면 특수한 처리 과정을 통해 옵셔널 타입을 해제 (Unwrapping) 하고 실제 값을 추출하여 사용해야 한다.

만일 처리 결과가 실패라면 옵셔널 타입의 값은 `nil` 값을 반환하므로 옵셔널 타입을 해제해서는 안된다.

<br>
<br>

### 1.1. 옵셔널 타입의 선언과 정의
---

일반 자료형을 옵셔널 타입으로 정의하는 방법은 매우 단순하다.

우리가 사용하는 자료형 뒤에 `?` 만 붙이면 된다.

`String?` 은 옵셔널 String 타입을 의미하고, `Int?`는 옵셔널 Int 타입을 의미한다.

옵셔널 타입의 변수에 값을 할당할 때에는 옵셔널 타입임을 인지할 필요가 거의 없다.

일반 변수처럼 생각하고 값을 대입해도 된다.

<br>
<br>

### 1.2. 옵셔널 값 처리
---

옵셔널 타입의 결과값은 그 자체로는 아무것도 할 수 없다.

옵셔널 타입은 애초에 연산을 지원하지 않는 타입이다.

따라서 옵셔널 타입과 일반 타입은 서로 연산이 불가능하며 옵셔널 타입끼리의 연산이나 결합 또한 지원하지 않는다.

이러한 옵셔널 값을 사용하는 방법에 대해 살펴본다.

우리가 전달받은 것은 `Optional` 이라는 객체이다.

그 객체 내부에 우리가 원하는 값이 들어있다. 

이 값을 우리가 원하는 대로 사용하기 위해서는 실제 값을 둘러싸고 있는 **옵셔널 객체를 해제**해야한다.

옵셔널 객체를 해제하면 일반 타입의 값이 되는데, 그 값이 우리가 직접 사용할 수 있는 값이다.

이처럼 옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 **옵셔널 해제 (Optional Unwrapping)** 이라고 한다.

옵셔널 해제 방식은 **명시적 해제**와 **묵시적 해제**로 나뉜다.

명시적 해제는 강제 해제와 비강제 해제로 나뉘고 묵시적 해제는 자동 해제와 `!` 연산자를 사용한 자동 해제로 나눌 수 있다.

강제 해제는 옵셔널 값의 `nil` 여부와는 상관없이 그냥 옵셔널을 무조건 해제하는 방식으로, 스위프트 공식 문서에서는 `Forced Unwrapping` 이라는 용어를 사용한다.

강제 해제 방법은 매우 간단하다. 옵셔널 변수 뒤에 `!` 연산자만 붙이면 옵셔널 객체가 해제되고 내부에 저장된 값을 추출할 수 있다.

아래 예시를 살펴본다.

```swift
var optInt:Int? = 3

print("Optional value : \(optInt)")
// Optional(3)

print("Forced Unwrapping value : \(optInt!)")
// 3
```

이처럼 옵셔널 타입으로부터 값을 강제 추출하기 위해서는 옵셔널 값 뒤에 `!` 연산자를 붙이면 된다.

이를 사용하면 옵셔널 타입끼리의 연산 또한 처리할 수 있다.

옵셔널 변수의 값이 `nil` 일 때, 강제 해제를 진행하면 오류가 발생한다.

그래서 옵셔널 변수나 상수등을 안전하게 사용하려면 조건이 따른다.

강제 해제 연산자를 사용할 때에는 옵셔널 값이 `nil`인지 우선 점검해야 한다.

이후 옵셔널 값이 `nil`이 아닐 때에만 강제 해제 연산자를 통해 값을 추출해야 한다.

```swift

var str = "123"
var intFromStr = Int(str)

if intFromStr != nil {
    print("값이 변환되었음, 변환값은 \(intFromStr)입니다.")
} else {
    print("값 변환에 실패하였음.")
}

```

옵셔널은 값이 없는 `nil` 이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 `nil`인지를 `if`, `guard`등을 통해 점검한 이후 사용해야한다.
<br>
<br>

### 1.3. 옵셔널 바인딩

앞에서 우리는 `nil` 여부를 체크하여 안전하게 옵셔널 타입을 해제할 수 있었다.

위에서 진행한 내용을 비강제적인 해제를 이용해 작성이 가능하다.

비강제 해재 구문은 `if` 문과 같은 구문 내에서 조건식 대신에 옵셔널 타입의 값을 변수 또는 상수에 할당하는 구문을 사용하는 방식으로, 옵셔널 바인딩 (Optional Binding) 이라고 한다.

`if`문의 조건절을 이용해 옵셔널 바인딩을 진행하는 예제를 살펴본다.

```swift

var str = "Swift"

if let intFromStr = Int(Str) {
    print("값이 변환되었음, 변환값은 \(intFromStr)입니다.")
}   else {
    print("값 변환에 실패하였음.")
}
```

앞서 살펴봤던 강제 해제와 비슷하지만, `intFrmStr`이 `if` 문의 조건절에서 상수로 선언되었다는 차이가 존재한다.

옵셔널 타입의 값이 만일 존재할 경우, 상수 또는 변수에 할당하는 과정을 거치며 자연스럽게 옵셔널 타입이 해제되지만, 옵셔널 타입의 값이 `nil`일 경우에는 값의 할당이 실패되어 실패 분기로 진행되도록 한다.

```swift
func intStr(str:String) {

    guard let intFromStr = Int(Str) else {
        print("값 변환에 실패하였음.")
        return
    }

    print("값이 변환되었음. 변환값은 \(intFromStr)입니다.")
}

```

위 구문은 `guard` 구문을 이용해 옵셔널 바인딩을 구현한 예제이다.

`guard` 구문 또한 작동 방식은 동일하다. `guard` 구문은 조건에 맞지 않으면 무조건 함수 실행을 종료시키기 때문에, 실행 흐름상 옵셔널 값이 해제되지 않으면 더이상 진행이 불가한 경우에 이용된다.

만일, 형식상 옵셔널로 정의해야 하지만, 실제로 사용할 때에는 절대 `nil` 값이 대입될 가능성이 없는 변수인 경우가 있다.

```swift
var value01: Int? = 10
```

위처럼 Optional Int 타입이지만 우리가 정확히 10을 대입해줘서 값이 있음을 확신할 때에는 묵시적 옵셔널 해제를 이용한다.

```swift
var value01 : Int! = 10
value01 + 5 // 15
```

<br>
<br>


## 2. 함수
---

함수는 일반 함수와 사용자 정의 함수로 나눌 수 있다.

일반 함수는 프로그래밍 언어 또는 프레임워크에서 제공하는 함수로 기본적 연산 또는 처리 등을 수행하기 위한 목적으로 사용된다.

대표적으로 표준출력에 사용되는 `print()`가 있다.

그 외의 필요에 따라 사용자가 직접 만들어 사용하는 함수를 **사용자 정의 함수** 라고한다.

함수를 만들어서 사용하는 이유는 다음과 같은 이점 때문이다.
#### 함수를 사용하는 이유
- 동일한 코드가 여러 곳에서 사용될 떄 이를 함수화 하면 재작성할 필요 없이 호출만으로 처리할 수 있다.

- 전체 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드의 흐름과 로직을 이해하기 쉽다.

- 비즈니스 로직을 변경해야 할 때 함수 내부만 수정하면 되므로 유지보수에 용이하다.


### 2.1. 사용자 정의 함수

사용자 정의 함수를 만드는 형식은 아래와 같다.

```swift

func 함수명 (매개변수1: 타입, 매개변수2: 타입...) -> 반환 타입 {
    
    함수 몸체

    return 반환값
}
```

타 언어에서 함수를 만드는 방법과 유사하다.

스위프트에서는 명시적으로 `func` 라는 키워드를 통해 함수를 선언한다.

만일 함수의 인자값이 필요 없는 경우라면 매개변수는 당연히 생략될 수 있다.

또한, 함수의 반환 타입을 표시할 때에는 `->` 기호와 함께 사용한다.

이 기호 다음에 작성된 자료형은 이 함수가 반환하는 값의 타입을 의미한다.

함수의 반환 타입 자료형에는 제약이 없다, 일반적인 String, Int, DOuble, Bool 등과 같은 기본 자료형 외에도 AnyObject, UITableCell 등 클래스의 객체도 사용할 수 있다.

반환값 또한 없을 경우에는 `->` 기호를 생략하면 된다.

### 2.2. 함수 호출


이제 함수를 호출하는 방법에 대해 살펴보자.

```swift

func incrementBy(amount: Int, numberOfTimes: Int) {
    var cnt = 0
    cnt = amount * numberOfTimes
}
```

위와 같은 함수가 존재한다고 해보자.

해당 함수는 두개의 매개변수를 받기 때문에 이 함수를 호출할 때는 다음과 같이 인자값 앞에 해당 매개변수의 레이블을 기재해야한다.

```swift
incrementBy(amount: 5, numberOfTimes: 20)
```

함수를 호출할 때에도 반드시 레이블을 포함하도록 강제하는 것은 스위프트 측이 강조하는 장점 즉, 레이블 미표기로 인한 혼란이나 불편함들이 함수에 레이블을 붙여서 호출하지 않는 대부분 언어에서 발생하지 않는다는 점이 그 사실을 증명한다.

<br>
<br>

### 2.3. 가변 인자

일반적으로 함수는 미리 정의된 형식과 개수에 맞는 인자값만 처리하는 것이 일반적이지만, 때에 따라서는 가변적 개수의 인자값을 입력받아야 할 때도 있다.

스위프트는 이러한 가변 인자 입력 방식을 지원하는데, 아래와 같이 함수를 정의할 때 매개변수명 다음에 `...` 연산자를 추가한다.

```swift
func 함수명(매개변수명 : 매개변수 타입 ...)

```

이렇게 정의된 매개변수는 가변 인자로 인식되어 인자의 개수를 제한하지 않고 인자값을 입력받으며, 입력된 인자값을 배열로 저장한다.

```swift
func avg(score: Int...) -> Double {

    var total = 0
    for r in score {        // score 배열 원소 순회
        total += r
    }

    return (Double(total) / Double(score.count))    // 총합값을 배열 길이로 나눔
}
```

이처럼 가변 인자값은 입력 개수를 특정할 수 없는 형태의 매개변수에서 사용된다.

빈번히 사용되지는 않지만, 가변 인자가 아니면 같은 결과를 얻기 위해 꽤 복잡한 과정을 거쳐야 할 경우가 있다고 하니 꼭 기억해두자.







<br>
<br>


### 정리
---

- **옵셔널은 프로그램의 안정성을 위한 개념이다.**

- **nil은 기존의 `objective-c` 에서는 빈 메모리 주소를 가리키는 값이었으나 스위프트에서는 단순히 `값이 없음`을 의미하게 되었다.**

- **일반 자료형에는 `nil`값을 할당할 수 없다. 하지만 각각의 일반 자료형들을 기반으로 옵셔널 타입이 만들어진다. (ex: Optional Int, Optional String)**

-   **옵셔널 타입이 가질 수 있는 값은 `nil` || `옵셔널 타입에 쌓여진 nil이 아닌 값`**

-   **옵셔널 객체를 해제하고 내부에 있는 값을 추출하는 과정을 **옵셔널 해제 (Optional Unwrapping)** 이라고 한다.**

-   **옵셔널 타입으로부터 값을 강제 추출하기 위해서는 옵셔널 값 뒤에 `!` 연산자를 붙이면 된다.**

-   **옵셔널은 값이 없는 `nil` 이거나 정상적인 값을 옵셔널 객체로 둘러싼 두 가지 경우만 존재하므로 옵셔널 값이 `nil`인지를 `if`, `guard`등을 통해 점검한 이후 사용해야한다.**

-   **`if` 문과 같은 구문 내에서 조건식 대신에 옵셔널 타입의 값을 변수 또는 상수에 할당하는 구문을 사용하는 방식으로, 옵셔널 바인딩 (Optional Binding) 이라고 한다. ex ) if let intFromStr = Int(Str) { }**

-   **[함수를 사용하는 이유](#함수를-사용하는-이유)**

-   **함수를 호출할 떄에는 매개변수 레이블을 기재하여 호출해야 한다.**

-   **가변인자 받는법 :func avg(score: Int `...`) -> Double {}**