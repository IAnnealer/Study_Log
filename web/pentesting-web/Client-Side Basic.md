## Client-Side Basic

---



`HTTP` 프로토콜은 `Connectionless` 와 `Stateless`한 특성을 갖고 있기 때문에 **웹 서버가 사용자를 식별**하기 위해 보편적으로 **쿠키와 세션**을 이용한다.

공격자는 사용자로부터 본인을 식별하기 위한 사용자 정보, 즉 **쿠키나 쿠키에 저장된 세션 아이디를 탈취해 사용자 권한을 얻거나, 사용자의 브라우저에서 자바스크립트를 실행하거나, 특별한 행위를 수행하도록 하여 사용자가 보낸것처럼 요청을 전송하는 것**이 클라이언트 사이드 취약점의 주 목적이다.

위와 같이 클라이언트 사이드 취약점이 발생할 수 있는 이유는 웹 브라우저는 `Stateful`한 상태를 유지하기 위해 모든 HTTP 요청에 쿠키를 함께 보내기 때문이다.



### Cross Site Scripting

----

**서버의 응답에 공격자가 삽입한 악성 스크립트**를 받은 **사용자의 웹 브라우저에서 악성 스크립트가 실행**되는 취약점을 `Cross - Site Scripting` 공격이라고 한다. **( 즉, 공격 타겟이 클라이언트 )**

`XSS`는 임의의 악성 스크립트를 실행할 수 있으며 이를 통해 해당 웹 사이트의 사용자 쿠키 또는 세션을 탈취하여 
사용자의 권한을 얻거나, 사용자의 페이지를 변조하는 등 서비스를 이용중인 사용자에 대한 공격을 수행할 수 있다.

`XSS` 공격을 성공적으로 수행하기 위해서는 아래의 조건이 요구된다.

>1. **입력 데이터에 대한 충분한 검증 과정이 없어야 한다.**
>   - 입력한 데이터에 대한 충분한 검증 과정이 없이 악성 스크립트가 삽입될 수 있어야 한다.
>2. **서버의 응답 데이터가 웹 브라우저 내 페이지에 출력시 충분한 검증 과정이 없어야 한다.**
>   - 응답 데이터 출력시 악성 스크립트가 웹 브라우저의 렌더링 과정에 성공적으로 포함되어야 한다.

대표적인 예시로 게시판이 존재한다. 공격자가 악성 스크립트가 포함된 게시글의 검증이 이루어지지 않은 채 서버에 업로드 되고 다른 사용자가 해당 게시글을 조회하는 순간 공격자의 악성 스크립트가 사용자의 앱 브라우저에서 실행될 것이다.

**XSS**는 악성 스크립트가 전달되는 방식에 따라 **Reflected XSS**, **Stored XSS** 등으로 분류된다.
**악성 스크립트의 전달 방식에 차이**가 있을 뿐 사용자의 웹 브라우저에서 악성 스크립트를 실행한다는 근본적 취약점 원인은 동일하다.



#### XSS with Javascript

---

`Javascript`는 사용자의 웹 브라우저에서 화면을 동적으로 보여줄 수 있도록 자동으로 버튼을 누르거나 화면 구성을 바꾸는 등의 작업을 할 때 이용되는 언어이다. 이러한 UI적 측면 외에도 사용자와의 상호작용 없이 사용자의 권한으로 정보를 조회하거나 변경하는 등의 요청을 주고 응답을 받는 것도 가능하다.

**사용자의 권한을 가지고 있는 세션 쿠키**는 사용자에게 저장되어있고 웹 브라우저는 해당 쿠키에 접근할 수 있기 때문이다.

이외에도 웹 브라우저에서 출력되어지는 페이지의 내용을 조작하거나, 웹 브라우저의 위치를 공격자가 원하는 주소로 변경 가능하다.

이처럼 사용자의 입장에서 발생하는 행위를 동작 시킬 수 있기 때문에 자바스크립트는 XSS 공격시 많이 사용된다.

**간단한 에시**

```html
<script>

    // 사용자의 위치를 변경시킨다 -> 피싱 공격 등으로 이어짐.
    location.href = "https://duwjdtn11.tistory.com";
    
    // 새로운 윈도우 열기
    window.open("https://duwjdtn11.tistory.com");
</script>
```



#### Stored XSS

---

`Stored XSS`는 악성 스크립트가 서버 내 존재하는 DB 또는 파일 등의 형태로 저장되어 있다가 사용자가 이를 조회하는 순간 발생하는 형태의 XSS이다.

대표적인 예시로 게시판 서비스에서 작성된 게시물을 확인하는 과정에서 악성 스크립트가 포함된 게시물을 조회할 때 악성 스크립트가 실행되는 공격 방식이 있다.

게시판과 같이 서버 내 저장되어 있는 형태에서는 불특정 다수에게 공격이 가능하다는 점에서 높은 파급력을 가지지만, 악성 스크립트가 실행되는 페이지가 일반적으로 접근이 어려운 서비스일 경우 파급력이 달라질 수 있다.

![image](https://user-images.githubusercontent.com/33051018/75448066-e5edc280-59ad-11ea-9107-051d86e4a14c.png)



#### Reflected XSS

---

`Reflected XSS`는 악성 스크립트가 사용자의 요청 시 전송되는 형태이다.

**사용자의 요청 데이터가 서버의 응답에 포함되는 과정에서 HTML 등의 악성 스크립트가 그대로 출력되어 발생하게 된다.**

**`Reflected XSS`는 `Stored XSS`와 다르게 사용자의 요청 데이터에 의해 취약점이 발생하기 때문에, 변조된 데이터가 사용자의 요청으로 전송되는 형태를 유도하여야 한다.**

대표적 예시로는 게시판 서비스, 로그인 서비스에서 입력한 데이터에 의해 발생하는 방식이 있습니다.

사용자가 게시물 조회를 욫어 시 서버는 해당 요청에 대하여 조회한 결과를 응답에 출력하며, 편의성을 위해 사용자가 조회한 내용을 응답에 포함하기도 한다. 이 때 서버에서 악성 스크립트에 대한 방어를 적절히 하지 못하고 응답에 포함되어 웹브라우저 페이지에 출력시 반영(Reflected)되는 결과로 인해 `Reflected XSS`로 이어질 수 있다.

![image](https://user-images.githubusercontent.com/33051018/75448912-6bbe3d80-59af-11ea-94f1-9feec857a2cd.png)

`search`인자값으로 전달된 스크립트 구문이 페이지 소스에 그대로 반영되어 응답값으로 전달된 것을 확인할 수 있다.



#### Cross Site Request Forgery (CSRF)

---

웹 브라우저는 기본적으로 `Same-Origin-Policy`에 위반되지 않은 **모든 요청에 쿠키를 함께 전송**한다.

cf) `Same-Origin-Policy` : 다른 오리진의 리소스를 요청하거나 상호작용 하는 것을 제한하는 웹 브라우저 보안 정책

비정상적으로 사용자의 의도와는 무관하게 다른 사이트에 `HTTP` 요청을 보내는 공격을 `CSRF`공격이라 한다.

**`CSRF`공격을 통해 공격자가 얻을 수 있는 이득은 해당 세션 쿠키를 가진 사람만이 사용할 수 있는 기능을 요청할 수 있다는 것이다.**

`CSRF`공격을 성공적으로 수행하기 위해서는 아래의 2가지 조건이 요구된다.

>**1. 해당 웹 사이트가 쿠키를 이용한 인증 방식을 사용해야 한다.**
>
>- 모든 HTTP 전송에는 쿠키가 함께 전송되기 때문에 쿠키에 저장된 세션 아이디도 전송된다.
>
>**2. 공격자가 사전에 알 수 없는 파라미터가 존재해서는 안된다.**
>
>- 자동입력 방지 문자를 넣어야 하는 요청은 공격자가 미리 알 수 없다.
>- 패스워드 변경 기능에서 기존 패스워드를 입력 받는 다면 이 또한 공격자가 미리 알 수 없다.

CSRF 공격을 통해 해당 세션을 가진 사람만 사용할 수 있는 기능을 요청할 수 있다는 것이다.

기존 권한을 갖고 있는 사용자가 쓸 수 있는 정상적인 기능을 공격자가 사용자의 의도와 무관하게 요청을 보내 원하는 이득을 얻을 수 있습니다.

예를 들어, 공격자에게 임의 금액을 송금하게 만들어 금전적 이득을 얻거나, 사용자의 패스워드를 공격자가 임의로 설정한 값으로 변경해 게정을 탈취하거나, 관리자 권한을 가진 사용자를 공격해 공지사항 작성에 혼란을 야기할 수 있다.



#### Open Redirect

---

`Redirect`는 사용자의 `Location`을 이동 시키기 위해 사용하는 기능 중 하나이다.

리다이렉트가 사용되는 코드는 `HTTP Response` 300번대 영역을 통해 이동되거나, 자바스크립트를 통해 이동하는 경우가 대부분이며 이때 이동하는 주소가 공격자에 의해 변경될 경우 `Open Redirect`취약점이 발생한다.

```python
from flask import Flask, request, redirect

app = Flask(__name__)

@app.route('/redirect')
def index():
    return redirect(request.args.get('url'))
```

오픈 리다이렉트 취약점은 사용자가 접속한 도메인 사이트에 대한 신뢰를 무너뜨릴 수 있는 공격으로 오픈 리다이렉트 취약점을 통해 피싱사이트로 접속을 유도하거나, 다른 취약점 연계를 통해 사용자를 공격할 수 있다.

**오픈 리다이렉트의 공격 방법은 리다이렉트가 발생하는 경로에서 공격자의 입력값에 의해 리다이렉트 되는 주소가 변경될 경우.** 해당 경로와 공격자의 값이 함께 전달되도록 사용자를 유도하여 리다이렉트를 실행시킬 수 있다.



#### Click Jacking

---

`Click Jacking`은 웹 브라우저 화면에 렌더링되는 내용에 HTML, CSS, JS등과 같이 화면 출력에 영향을 미치는 요소들을 이용하여 사용자의 눈을 속여 클릭을 유도하는 공격방법이다.

외부 페이지 리소스를 불러올 수 있는 태그 엘리먼트 (ex: frame, iframe, object, embed, applet)등을 사용한다.

사용자의 클릭을 유도하는 페이지를 구성 후, 그 페이지 위에 `iframe` 태그등을 통해 페이지를 로드한다.

그리고 CSS 요소를 조절하여 눈에 보이지 않도록 숨기는 등의 방법을 통해 공격을 할 수 있다.

사용자가 보는 페이지와 실제로 누르는 곳에 차이가 있는 이유는 `iframe` 태그가 웹 브라우저 상에서는 더 위에 위치하기 때문에 클릭 시 동작을 하게되는 원리이다.



